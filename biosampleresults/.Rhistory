produce_counts_from_tables <- function(directory_path="/Users/ctern/Downloads/images/090519-pm/2618", file_extension=".xls",
user_bw=.2, min_px_Area=5, plot_dist_Area=FALSE, remove_large_outliers=TRUE, vec_names=NA){
#user_bw: bandwidth used to compute the kernel density estimates of the Area distribution (see ?density)
#min_px_Area: lower threshold that can be used to remove small dust particles. This threshold should not be set to the minimal expected Area of an egg (the first peak of a bimodal distribution is always removed in a later step)
#plot_dist_Area: if TRUE, the function will plot the Area distribution with the cutoff used to remove outliers (Boolean)
#remove_large_outliers: if TRUE, large particles are also removed from the final egg count
#vec_names: each file name will be split using the "_" separator into several column to create a final data frame. The column names default values will be set to "ID_#" unless specified in vec_names.
temp_dir=getwd()
setwd(directory_path)
all_files=list.files(path=directory_path, pattern= file_extension)
cat(sprintf("Loading input data from %s files... ", length(all_files)))
read_all=lapply(all_files,read.table,sep="\t",header=TRUE)
cat(sprintf("DONE\n"))
counts=do.call(rbind,read_all)
nb_lines_per_file=sapply(all_files,countLines)-1
#Should be TRUE
#sum(nb_lines_per_file)==nrow(counts)
## Add a column with the name of the file #id
counts$id=rep(all_files, nb_lines_per_file)
#counts=subset(counts,Area>= min_px_Area & counts$Major/counts$Minor < quantile(counts$Major/counts$Minor, .9999))
counts=subset(counts,Area >= min_px_Area)
density_dist=density(log10(counts$Area),bw=user_bw)
tp=suppressWarnings(turnpoints(density_dist$y))
# We use the first pit as the cutoff
#(density_dist$x[tp$pits])[1]
cat(sprintf("Remove %s small outliers (%s %%)\n", nrow(subset(counts,log10(Area)< density_dist$x[tp$peaks][1])),round(10000*nrow(subset(counts,log10(Area)< density_dist$x[tp$peaks][1]))/nrow(counts))/100))
cutoff_outliers=Inf
if(remove_large_outliers){
cutoff_outliers=density_dist$x[tp$peaks][2]+2*(density_dist$x[tp$peaks][2]-density_dist$x[tp$pits][1])
cat(sprintf("Remove %s large outliers (%s %%)\n", nrow(subset(counts,Area> 10^cutoff_outliers)),round(1000*nrow(subset(counts,Area > 10^cutoff_outliers))/nrow(counts))/10))
}
########
if(plot_dist_Area){
quartz(height=3.5,width=6)
plot(density_dist, xlab=expression("Area of the detected particles"~(log10(px^2))), ylab="Density", main="", bty = "n", lwd = 2)
abline(v= (density_dist$x[tp$pits][1]),col="red")
if(remove_large_outliers) abline(v= (cutoff_outliers),col="red")
}
## create the count table now
counts_filt=subset(counts,log10(Area)< cutoff_outliers & log10(Area)>(density_dist$x[tp$pits][1]))
labels_from_id=tstrsplit(strsplit(counts_filt$id,file_extension),"_")
temp_data_frame=unique(data.frame(labels_from_id))
temp_data_frame=cbind(temp_data_frame,tapply(counts_filt$Major, counts_filt$id, length))
if(is.na(vec_names)){
names(temp_data_frame)=c(paste0("ID_",1:length(labels_from_id)),"nb_eggs")
}else{
names(temp_data_frame)=c(vec_names,"nb_eggs")
}
setwd(temp_dir)
return(list(temp_data_frame,counts_filt))
}
produce_counts_from_tables()[[1]]
produce_counts_from_tables <- function(directory_path="/Users/ctern/Downloads/images/090619/2620", file_extension=".xls",
user_bw=.2, min_px_Area=5, plot_dist_Area=FALSE, remove_large_outliers=TRUE, vec_names=NA){
#user_bw: bandwidth used to compute the kernel density estimates of the Area distribution (see ?density)
#min_px_Area: lower threshold that can be used to remove small dust particles. This threshold should not be set to the minimal expected Area of an egg (the first peak of a bimodal distribution is always removed in a later step)
#plot_dist_Area: if TRUE, the function will plot the Area distribution with the cutoff used to remove outliers (Boolean)
#remove_large_outliers: if TRUE, large particles are also removed from the final egg count
#vec_names: each file name will be split using the "_" separator into several column to create a final data frame. The column names default values will be set to "ID_#" unless specified in vec_names.
temp_dir=getwd()
setwd(directory_path)
all_files=list.files(path=directory_path, pattern= file_extension)
cat(sprintf("Loading input data from %s files... ", length(all_files)))
read_all=lapply(all_files,read.table,sep="\t",header=TRUE)
cat(sprintf("DONE\n"))
counts=do.call(rbind,read_all)
nb_lines_per_file=sapply(all_files,countLines)-1
#Should be TRUE
#sum(nb_lines_per_file)==nrow(counts)
## Add a column with the name of the file #id
counts$id=rep(all_files, nb_lines_per_file)
#counts=subset(counts,Area>= min_px_Area & counts$Major/counts$Minor < quantile(counts$Major/counts$Minor, .9999))
counts=subset(counts,Area >= min_px_Area)
density_dist=density(log10(counts$Area),bw=user_bw)
tp=suppressWarnings(turnpoints(density_dist$y))
# We use the first pit as the cutoff
#(density_dist$x[tp$pits])[1]
cat(sprintf("Remove %s small outliers (%s %%)\n", nrow(subset(counts,log10(Area)< density_dist$x[tp$peaks][1])),round(10000*nrow(subset(counts,log10(Area)< density_dist$x[tp$peaks][1]))/nrow(counts))/100))
cutoff_outliers=Inf
if(remove_large_outliers){
cutoff_outliers=density_dist$x[tp$peaks][2]+2*(density_dist$x[tp$peaks][2]-density_dist$x[tp$pits][1])
cat(sprintf("Remove %s large outliers (%s %%)\n", nrow(subset(counts,Area> 10^cutoff_outliers)),round(1000*nrow(subset(counts,Area > 10^cutoff_outliers))/nrow(counts))/10))
}
########
if(plot_dist_Area){
quartz(height=3.5,width=6)
plot(density_dist, xlab=expression("Area of the detected particles"~(log10(px^2))), ylab="Density", main="", bty = "n", lwd = 2)
abline(v= (density_dist$x[tp$pits][1]),col="red")
if(remove_large_outliers) abline(v= (cutoff_outliers),col="red")
}
## create the count table now
counts_filt=subset(counts,log10(Area)< cutoff_outliers & log10(Area)>(density_dist$x[tp$pits][1]))
labels_from_id=tstrsplit(strsplit(counts_filt$id,file_extension),"_")
temp_data_frame=unique(data.frame(labels_from_id))
temp_data_frame=cbind(temp_data_frame,tapply(counts_filt$Major, counts_filt$id, length))
if(is.na(vec_names)){
names(temp_data_frame)=c(paste0("ID_",1:length(labels_from_id)),"nb_eggs")
}else{
names(temp_data_frame)=c(vec_names,"nb_eggs")
}
setwd(temp_dir)
return(list(temp_data_frame,counts_filt))
}
produce_counts_from_tables()[[1]]
produce_counts_from_tables()[[1]]
produce_counts_from_tables()[[1]]
produce_counts_from_tables <- function(directory_path="/Users/ctern/Downloads/images/070119/0892", file_extension=".xls",
user_bw=.2, min_px_Area=5, plot_dist_Area=FALSE, remove_large_outliers=TRUE, vec_names=NA){
#user_bw: bandwidth used to compute the kernel density estimates of the Area distribution (see ?density)
#min_px_Area: lower threshold that can be used to remove small dust particles. This threshold should not be set to the minimal expected Area of an egg (the first peak of a bimodal distribution is always removed in a later step)
#plot_dist_Area: if TRUE, the function will plot the Area distribution with the cutoff used to remove outliers (Boolean)
#remove_large_outliers: if TRUE, large particles are also removed from the final egg count
#vec_names: each file name will be split using the "_" separator into several column to create a final data frame. The column names default values will be set to "ID_#" unless specified in vec_names.
temp_dir=getwd()
setwd(directory_path)
all_files=list.files(path=directory_path, pattern= file_extension)
cat(sprintf("Loading input data from %s files... ", length(all_files)))
read_all=lapply(all_files,read.table,sep="\t",header=TRUE)
cat(sprintf("DONE\n"))
counts=do.call(rbind,read_all)
nb_lines_per_file=sapply(all_files,countLines)-1
#Should be TRUE
#sum(nb_lines_per_file)==nrow(counts)
## Add a column with the name of the file #id
counts$id=rep(all_files, nb_lines_per_file)
#counts=subset(counts,Area>= min_px_Area & counts$Major/counts$Minor < quantile(counts$Major/counts$Minor, .9999))
counts=subset(counts,Area >= min_px_Area)
density_dist=density(log10(counts$Area),bw=user_bw)
tp=suppressWarnings(turnpoints(density_dist$y))
# We use the first pit as the cutoff
#(density_dist$x[tp$pits])[1]
cat(sprintf("Remove %s small outliers (%s %%)\n", nrow(subset(counts,log10(Area)< density_dist$x[tp$peaks][1])),round(10000*nrow(subset(counts,log10(Area)< density_dist$x[tp$peaks][1]))/nrow(counts))/100))
cutoff_outliers=Inf
if(remove_large_outliers){
cutoff_outliers=density_dist$x[tp$peaks][2]+2*(density_dist$x[tp$peaks][2]-density_dist$x[tp$pits][1])
cat(sprintf("Remove %s large outliers (%s %%)\n", nrow(subset(counts,Area> 10^cutoff_outliers)),round(1000*nrow(subset(counts,Area > 10^cutoff_outliers))/nrow(counts))/10))
}
########
if(plot_dist_Area){
quartz(height=3.5,width=6)
plot(density_dist, xlab=expression("Area of the detected particles"~(log10(px^2))), ylab="Density", main="", bty = "n", lwd = 2)
abline(v= (density_dist$x[tp$pits][1]),col="red")
if(remove_large_outliers) abline(v= (cutoff_outliers),col="red")
}
## create the count table now
counts_filt=subset(counts,log10(Area)< cutoff_outliers & log10(Area)>(density_dist$x[tp$pits][1]))
labels_from_id=tstrsplit(strsplit(counts_filt$id,file_extension),"_")
temp_data_frame=unique(data.frame(labels_from_id))
temp_data_frame=cbind(temp_data_frame,tapply(counts_filt$Major, counts_filt$id, length))
if(is.na(vec_names)){
names(temp_data_frame)=c(paste0("ID_",1:length(labels_from_id)),"nb_eggs")
}else{
names(temp_data_frame)=c(vec_names,"nb_eggs")
}
setwd(temp_dir)
return(list(temp_data_frame,counts_filt))
}
produce_counts_from_tables()[[1]]
produce_counts_from_tables <- function(directory_path="/Users/ctern/Downloads/images/070119/0896", file_extension=".xls",
user_bw=.2, min_px_Area=5, plot_dist_Area=FALSE, remove_large_outliers=TRUE, vec_names=NA){
#user_bw: bandwidth used to compute the kernel density estimates of the Area distribution (see ?density)
#min_px_Area: lower threshold that can be used to remove small dust particles. This threshold should not be set to the minimal expected Area of an egg (the first peak of a bimodal distribution is always removed in a later step)
#plot_dist_Area: if TRUE, the function will plot the Area distribution with the cutoff used to remove outliers (Boolean)
#remove_large_outliers: if TRUE, large particles are also removed from the final egg count
#vec_names: each file name will be split using the "_" separator into several column to create a final data frame. The column names default values will be set to "ID_#" unless specified in vec_names.
temp_dir=getwd()
setwd(directory_path)
all_files=list.files(path=directory_path, pattern= file_extension)
cat(sprintf("Loading input data from %s files... ", length(all_files)))
read_all=lapply(all_files,read.table,sep="\t",header=TRUE)
cat(sprintf("DONE\n"))
counts=do.call(rbind,read_all)
nb_lines_per_file=sapply(all_files,countLines)-1
#Should be TRUE
#sum(nb_lines_per_file)==nrow(counts)
## Add a column with the name of the file #id
counts$id=rep(all_files, nb_lines_per_file)
#counts=subset(counts,Area>= min_px_Area & counts$Major/counts$Minor < quantile(counts$Major/counts$Minor, .9999))
counts=subset(counts,Area >= min_px_Area)
density_dist=density(log10(counts$Area),bw=user_bw)
tp=suppressWarnings(turnpoints(density_dist$y))
# We use the first pit as the cutoff
#(density_dist$x[tp$pits])[1]
cat(sprintf("Remove %s small outliers (%s %%)\n", nrow(subset(counts,log10(Area)< density_dist$x[tp$peaks][1])),round(10000*nrow(subset(counts,log10(Area)< density_dist$x[tp$peaks][1]))/nrow(counts))/100))
cutoff_outliers=Inf
if(remove_large_outliers){
cutoff_outliers=density_dist$x[tp$peaks][2]+2*(density_dist$x[tp$peaks][2]-density_dist$x[tp$pits][1])
cat(sprintf("Remove %s large outliers (%s %%)\n", nrow(subset(counts,Area> 10^cutoff_outliers)),round(1000*nrow(subset(counts,Area > 10^cutoff_outliers))/nrow(counts))/10))
}
########
if(plot_dist_Area){
quartz(height=3.5,width=6)
plot(density_dist, xlab=expression("Area of the detected particles"~(log10(px^2))), ylab="Density", main="", bty = "n", lwd = 2)
abline(v= (density_dist$x[tp$pits][1]),col="red")
if(remove_large_outliers) abline(v= (cutoff_outliers),col="red")
}
## create the count table now
counts_filt=subset(counts,log10(Area)< cutoff_outliers & log10(Area)>(density_dist$x[tp$pits][1]))
labels_from_id=tstrsplit(strsplit(counts_filt$id,file_extension),"_")
temp_data_frame=unique(data.frame(labels_from_id))
temp_data_frame=cbind(temp_data_frame,tapply(counts_filt$Major, counts_filt$id, length))
if(is.na(vec_names)){
names(temp_data_frame)=c(paste0("ID_",1:length(labels_from_id)),"nb_eggs")
}else{
names(temp_data_frame)=c(vec_names,"nb_eggs")
}
setwd(temp_dir)
return(list(temp_data_frame,counts_filt))
}
produce_counts_from_tables()[[1]]
produce_counts_from_tables()[[1]]
produce_counts_from_tables <- function(directory_path="/Users/ctern/Downloads/images/070119-36/0920", file_extension=".xls",
user_bw=.2, min_px_Area=5, plot_dist_Area=FALSE, remove_large_outliers=TRUE, vec_names=NA){
#user_bw: bandwidth used to compute the kernel density estimates of the Area distribution (see ?density)
#min_px_Area: lower threshold that can be used to remove small dust particles. This threshold should not be set to the minimal expected Area of an egg (the first peak of a bimodal distribution is always removed in a later step)
#plot_dist_Area: if TRUE, the function will plot the Area distribution with the cutoff used to remove outliers (Boolean)
#remove_large_outliers: if TRUE, large particles are also removed from the final egg count
#vec_names: each file name will be split using the "_" separator into several column to create a final data frame. The column names default values will be set to "ID_#" unless specified in vec_names.
temp_dir=getwd()
setwd(directory_path)
all_files=list.files(path=directory_path, pattern= file_extension)
cat(sprintf("Loading input data from %s files... ", length(all_files)))
read_all=lapply(all_files,read.table,sep="\t",header=TRUE)
cat(sprintf("DONE\n"))
counts=do.call(rbind,read_all)
nb_lines_per_file=sapply(all_files,countLines)-1
#Should be TRUE
#sum(nb_lines_per_file)==nrow(counts)
## Add a column with the name of the file #id
counts$id=rep(all_files, nb_lines_per_file)
#counts=subset(counts,Area>= min_px_Area & counts$Major/counts$Minor < quantile(counts$Major/counts$Minor, .9999))
counts=subset(counts,Area >= min_px_Area)
density_dist=density(log10(counts$Area),bw=user_bw)
tp=suppressWarnings(turnpoints(density_dist$y))
# We use the first pit as the cutoff
#(density_dist$x[tp$pits])[1]
cat(sprintf("Remove %s small outliers (%s %%)\n", nrow(subset(counts,log10(Area)< density_dist$x[tp$peaks][1])),round(10000*nrow(subset(counts,log10(Area)< density_dist$x[tp$peaks][1]))/nrow(counts))/100))
cutoff_outliers=Inf
if(remove_large_outliers){
cutoff_outliers=density_dist$x[tp$peaks][2]+2*(density_dist$x[tp$peaks][2]-density_dist$x[tp$pits][1])
cat(sprintf("Remove %s large outliers (%s %%)\n", nrow(subset(counts,Area> 10^cutoff_outliers)),round(1000*nrow(subset(counts,Area > 10^cutoff_outliers))/nrow(counts))/10))
}
########
if(plot_dist_Area){
quartz(height=3.5,width=6)
plot(density_dist, xlab=expression("Area of the detected particles"~(log10(px^2))), ylab="Density", main="", bty = "n", lwd = 2)
abline(v= (density_dist$x[tp$pits][1]),col="red")
if(remove_large_outliers) abline(v= (cutoff_outliers),col="red")
}
## create the count table now
counts_filt=subset(counts,log10(Area)< cutoff_outliers & log10(Area)>(density_dist$x[tp$pits][1]))
labels_from_id=tstrsplit(strsplit(counts_filt$id,file_extension),"_")
temp_data_frame=unique(data.frame(labels_from_id))
temp_data_frame=cbind(temp_data_frame,tapply(counts_filt$Major, counts_filt$id, length))
if(is.na(vec_names)){
names(temp_data_frame)=c(paste0("ID_",1:length(labels_from_id)),"nb_eggs")
}else{
names(temp_data_frame)=c(vec_names,"nb_eggs")
}
setwd(temp_dir)
return(list(temp_data_frame,counts_filt))
}
produce_counts_from_tables()[[1]]
produce_counts_from_tables()[[1]]
produce_counts_from_tables <- function(directory_path="/Users/ctern/Downloads/images/070119-36/0922", file_extension=".xls",
user_bw=.2, min_px_Area=5, plot_dist_Area=FALSE, remove_large_outliers=TRUE, vec_names=NA){
#user_bw: bandwidth used to compute the kernel density estimates of the Area distribution (see ?density)
#min_px_Area: lower threshold that can be used to remove small dust particles. This threshold should not be set to the minimal expected Area of an egg (the first peak of a bimodal distribution is always removed in a later step)
#plot_dist_Area: if TRUE, the function will plot the Area distribution with the cutoff used to remove outliers (Boolean)
#remove_large_outliers: if TRUE, large particles are also removed from the final egg count
#vec_names: each file name will be split using the "_" separator into several column to create a final data frame. The column names default values will be set to "ID_#" unless specified in vec_names.
temp_dir=getwd()
setwd(directory_path)
all_files=list.files(path=directory_path, pattern= file_extension)
cat(sprintf("Loading input data from %s files... ", length(all_files)))
read_all=lapply(all_files,read.table,sep="\t",header=TRUE)
cat(sprintf("DONE\n"))
counts=do.call(rbind,read_all)
nb_lines_per_file=sapply(all_files,countLines)-1
#Should be TRUE
#sum(nb_lines_per_file)==nrow(counts)
## Add a column with the name of the file #id
counts$id=rep(all_files, nb_lines_per_file)
#counts=subset(counts,Area>= min_px_Area & counts$Major/counts$Minor < quantile(counts$Major/counts$Minor, .9999))
counts=subset(counts,Area >= min_px_Area)
density_dist=density(log10(counts$Area),bw=user_bw)
tp=suppressWarnings(turnpoints(density_dist$y))
# We use the first pit as the cutoff
#(density_dist$x[tp$pits])[1]
cat(sprintf("Remove %s small outliers (%s %%)\n", nrow(subset(counts,log10(Area)< density_dist$x[tp$peaks][1])),round(10000*nrow(subset(counts,log10(Area)< density_dist$x[tp$peaks][1]))/nrow(counts))/100))
cutoff_outliers=Inf
if(remove_large_outliers){
cutoff_outliers=density_dist$x[tp$peaks][2]+2*(density_dist$x[tp$peaks][2]-density_dist$x[tp$pits][1])
cat(sprintf("Remove %s large outliers (%s %%)\n", nrow(subset(counts,Area> 10^cutoff_outliers)),round(1000*nrow(subset(counts,Area > 10^cutoff_outliers))/nrow(counts))/10))
}
########
if(plot_dist_Area){
quartz(height=3.5,width=6)
plot(density_dist, xlab=expression("Area of the detected particles"~(log10(px^2))), ylab="Density", main="", bty = "n", lwd = 2)
abline(v= (density_dist$x[tp$pits][1]),col="red")
if(remove_large_outliers) abline(v= (cutoff_outliers),col="red")
}
## create the count table now
counts_filt=subset(counts,log10(Area)< cutoff_outliers & log10(Area)>(density_dist$x[tp$pits][1]))
labels_from_id=tstrsplit(strsplit(counts_filt$id,file_extension),"_")
temp_data_frame=unique(data.frame(labels_from_id))
temp_data_frame=cbind(temp_data_frame,tapply(counts_filt$Major, counts_filt$id, length))
if(is.na(vec_names)){
names(temp_data_frame)=c(paste0("ID_",1:length(labels_from_id)),"nb_eggs")
}else{
names(temp_data_frame)=c(vec_names,"nb_eggs")
}
setwd(temp_dir)
return(list(temp_data_frame,counts_filt))
}
produce_counts_from_tables()[[1]]
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("SeqArray")
browseVignettes("SeqArray")
help()
help(SeqArray)
help("SeqArray")
library(SeqArray)
help("SeqArray")
??SeqArray
help()
help("seqVCF2GDS",package="SeqArray")
library(SeqArray)
library(SeqArray)
vcf.file <- "~/Downloads/GitHub/simCline/biosampleresults/pooledData.vcf"
gds.output <- "~/Downloads/GitHub/simCline/biosampleresults/pooledData.gds"
seqVCF2GDS(vcf.fn = vcf.file, out.fn = gds.output)
snp.dt <- data.table(chr=seqGetData(gds.output, "chromosome"),
pos=seqGetData(gds.output, "position"),
nAlleles=seqGetData(gds.output, "$num_allele"),
id=seqGetData(gds.output, "variant.id"),
seqMissing(gds.output, per.variant=T))
table(snp.dt$chr)
prop.table(table(snp.dt$nAlleles))
snp.dt <- data.frame(chr=seqGetData(gds.output, "chromosome"),
pos=seqGetData(gds.output, "position"),
nAlleles=seqGetData(gds.output, "$num_allele"),
id=seqGetData(gds.output, "variant.id"),
seqMissing(gds.output, per.variant=T))
library(SeqArray)
snp.dt <- data.frame(chr=seqGetData(gds.output, "chromosome"),
pos=seqGetData(gds.output, "position"),
nAlleles=seqGetData(gds.output, "$num_allele"),
id=seqGetData(gds.output, "variant.id"),
seqMissing(gds.output, per.variant=T))
chr=seqGetData(gds.output, "chromosome")
gds.output <- "~/Downloads/GitHub/simCline/biosampleresults/pooledData.gds"
snp.dt <- data.frame(chr=seqGetData(gds.output, "chromosome"),
pos=seqGetData(gds.output, "position"),
nAlleles=seqGetData(gds.output, "$num_allele"),
id=seqGetData(gds.output, "variant.id"),
seqMissing(gds.output, per.variant=T))
??seqGetData
gds.file <- seqOpen(gds.output)
gds.file <- seqOpen(gds.output)
snp.dt <- data.frame(chr=seqGetData(gds.file, "chromosome"),
pos=seqGetData(gds.file, "position"),
nAlleles=seqGetData(gds.file, "$num_allele"),
id=seqGetData(gds.file, "variant.id"),
seqMissing(gds.file, per.variant=T))
table(snp.dt$chr)
prop.table(table(snp.dt$nAlleles))
seqMissing(genofile, per.variant=T))
table(snp.dt$chr)
prop.table(table(snp.dt$nAlleles))
seqSetFilter(genofile, variant.id=snp.dt[nAlleles==2])
seqSetFilter(genofile, variant.id=snp.dt[nAlleles==2]$id)
seqGetData(genofile, “annotation/format/AD”)
seqGetData(genofile, “annotation/format/RD”)
seqSetFilter(gds.file, variant.id=snp.dt[nAlleles==2])
seqSetFilter(gds.file, variant.id=snp.dt[nAlleles==2]$id)
seqGetData(gds.file, “annotation/format/AD”)
seqGetData(gds.file, “annotation/format/RD”)
seqSetFilter(gds.file, variant.id=snp.dt[nAlleles==2])
gds.file <- "~/Downloads/GitHub/simCline/biosampleresults/pooledData.gds"
seqVCF2GDS(vcf.fn = vcf.file, out.fn = gds.file)
gds.output <- seqOpen(gds.output)
gds.output <- seqOpen(gds.file)
seqSetFilter(gds.file, variant.id=snp.dt[nAlleles==2])
gds.file <- seqOpen(gds.output)
snp.dt <- data.frame(chr=seqGetData(gds.file, "chromosome"),
pos=seqGetData(gds.file, "position"),
nAlleles=seqGetData(gds.file, "$num_allele"),
id=seqGetData(gds.file, "variant.id"),
seqMissing(gds.file, per.variant=T))
library(SeqArray)
library(ggplot2)
library(data.table)
#load vcf and gds files
vcf.file <- "~/Downloads/GitHub/simCline/biosampleresults/pooledData.vcf"
gds.output <- "~/Downloads/GitHub/simCline/biosampleresults/pooledData.gds"
ds.file <- seqOpen(gds.output)
snp.dt <- data.table(chr=seqGetData(gds.file, "chromosome"),
pos=seqGetData(gds.file, "position"),
nAlleles=seqGetData(gds.file, "$num_allele"),
id=seqGetData(gds.file, "variant.id"),
seqMissing(gds.f
ile, per.variant=T))
snp.dt <- data.table(chr=seqGetData(gds.file, "chromosome"),
pos=seqGetData(gds.file, "position"),
nAlleles=seqGetData(gds.file, "$num_allele"),
id=seqGetData(gds.file, "variant.id"),
seqMissing(gds.file, per.variant=T))
#set up data table
gds.file <- seqOpen(gds.output)
snp.dt <- data.table(chr=seqGetData(gds.file, "chromosome"),
pos=seqGetData(gds.file, "position"),
nAlleles=seqGetData(gds.file, "$num_allele"),
id=seqGetData(gds.file, "variant.id"),
seqMissing(gds.file, per.variant=T))
#load vcf and gds files
vcf.file <- "~/Downloads/GitHub/simCline/biosampleresults/pooledData.vcf"
gds.output <- "~/Downloads/GitHub/simCline/biosampleresults/pooledData.gds"
#set up data table
gds.file <- seqOpen(gds.output)
# #filtering where chromosome is not Dmel
snp.dt <- snp.dt[grepl("Dsim_Scf_2L|Dsim_Scf_2R|Dsim_Scf_3L|Dsim_Scf_3R", chr)]
snp.dt <- data.table(chr=seqGetData(gds.file, "chromosome"),
pos=seqGetData(gds.file, "position"),
nAlleles=seqGetData(gds.file, "$num_allele"),
id=seqGetData(gds.file, "variant.id"),
seqMissing(gds.file, per.variant=T))
library(SeqArray)
library(ggplot2)
library(data.table)
#load vcf and gds files
vcf.file <- "~/Downloads/GitHub/simCline/biosampleresults/pooledData.vcf"
gds.output <- "~/Downloads/GitHub/simCline/biosampleresults/pooledData.gds"
#set up data table
gds.file <- seqOpen(gds.output)
snp.dt <- data.table(chr=seqGetData(gds.file, "chromosome"),
pos=seqGetData(gds.file, "position"),
nAlleles=seqGetData(gds.file, "$num_allele"),
id=seqGetData(gds.file, "variant.id"),
seqMissing(gds.file, per.variant=T))
# #filtering where chromosome is not Dmel
snp.dt <- snp.dt[grepl("Dsim_Scf_2L|Dsim_Scf_2R|Dsim_Scf_3L|Dsim_Scf_3R", chr)]
##keep only where 2 alleles
nAlleles=seqGetData(gds.file, "$num_allele")
seqSetFilter(gds.file, variant.id=snp.dt[nAlleles==2]$id[1:1000])
adList<- seqGetData(gds.file, "annotation/format/AD")
rdList<- seqGetData(gds.file, "annotation/format/RD")
dat <- data.table(ad=expand.grid(adList$data)$Var1,
rd=expand.grid(rdList$data)$Var1,
population=rep(seqGetData(gds.file, "sample.id"), dim(adList$data)[2]),
variant.id=rep(seqGetData(gds.file, "variant.id"), each=dim(adList$data)[1]))
dat.ag <- dat[,list(nmissing=sum(is.na(ad)), aveAD=mean(ad, na.rm=T), freqAlt=ad/rd), list(variant.id)]
ggplot(data=dat.ag, aes(x=freqAlt)) + geom_histogram()
dat.ag <- dat[,list(nmissing=sum(is.na(ad)), aveAD=mean(ad, na.rm=T), freqAlt=ad/(ad+rd)), list(variant.id)]
ggplot(data=dat.ag, aes(x=freqAlt)) + geom_histogram()
dat.ag <- dat[,list(nmissing=sum(is.na(ad)), aveAD=mean(ad, na.rm=T), freqAlt=sum(ad)/sum(ad+rd)), list(variant.id)]
ggplot(data=dat.ag, aes(x=freqAlt)) + geom_histogram()
dat.ag <- dat[,list(nmissing=sum(is.na(ad)), aveAD=mean(ad, na.rm=T), freqAlt=sum(ad, na.rm=T)/sum(ad+rd, na.rm=T)), list(variant.id)]
ggplot(data=dat.ag, aes(x=freqAlt)) + geom_histogram()
dat.ag <- dat[,list(nmissing=sum(is.na(ad)), aveAD=mean(ad, na.rm=T), freqAlt=mean(ad/(ad+rd), na.rm=T)), list(variant.id)]
ggplot(data=dat.ag, aes(x=freqAlt)) + geom_histogram()
ggplot(data=dat.ag, aes(x=nmissing)) + geom_histogram()
library(SeqArray)
library(ggplot2)
library(data.table)
setwd("~/Downloads/GitHub/simCline/biosampleresults/")
gds.output <- "~/Downloads/GitHub/simCline/biosampleresults/pooled.gds"
snp.dt <- data.table(chr=seqGetData(gds.file, "chromosome"),
pos=seqGetData(gds.file, "position"),
nAlleles=seqGetData(gds.file, "$num_allele"),
id=seqGetData(gds.file, "variant.id"),
seqMissing(gds.file, per.variant=T))
# filter where not dmels
snp.dt <- snp.dt[grepl("Dsim_Scf_2L|Dsim_Scf_2R|Dsim_Scf_3L|Dsim_Scf_3R", chr)]
gds.output <- "~/Downloads/GitHub/simCline/biosampleresults/pooled.gds"
gds.file <- seqOpen(gds.output)
snp.dt <- data.table(chr=seqGetData(gds.file, "chromosome"),
pos=seqGetData(gds.file, "position"),
nAlleles=seqGetData(gds.file, "$num_allele"),
id=seqGetData(gds.file, "variant.id"),
seqMissing(gds.file, per.variant=T))
# filter where not dmels
snp.dt <- snp.dt[grepl("Dsim_Scf_2L|Dsim_Scf_2R|Dsim_Scf_3L|Dsim_Scf_3R", chr)]
# keep only where 2 alleles
nAlleles=seqGetData(gds.file, "$num_allele")
#sample 100,000 ids
samp.ids <- as.numeric(sample(x=as.character(snp.dt[nAlleles==2]$id), size=10000))
seqSetFilter(gds.file, variant.id=samp.ids)
################
adList<- seqGetData(gds.file, "annotation/format/AD")
rdList<- seqGetData(gds.file, "annotation/format/RD")
# compile variables of interest
dat <- data.table(ad=expand.grid(adList$data)$Var1,
rd=expand.grid(rdList$data)$Var1,
population=rep(seqGetData(gds.file, "sample.id"), dim(adList$data)[2]),
variant.id=rep(seqGetData(gds.file, "variant.id"), each=dim(adList$data)[1]))
dat[,freqAlt:=ad/(ad+rd)]
#functions of dat[] variables
dat.ag <- dat[,list(population=population,nmissing=sum(is.na(ad)), aveAD=mean(ad, na.rm=T), freqAlt=sum(ad, na.rm=T)/sum(ad+rd, na.rm=T)), list(variant.id)]
#plot frequency of alternate alleles for each of the 422 populations
ggplot(data=dat, aes(x=freqAlt)) + geom_histogram() + facet_wrap(~identifier)
concatenated<- fread("concatenated.csv")
setnames(dat, "population", "identifier")
setkey(concatenated, identifier)
setkey(dat, identifier)
dat.merged <- merge(dat, concatenated)
#plot frequency of alternate alleles for each of the 422 populations
ggplot(data=dat, aes(x=freqAlt)) + geom_histogram() + facet_wrap(~identifier)
#plot frequency of alternate alleles for each of the 422 populations
ggplot(data=dat, aes(x=freqAlt)) + geom_histogram() + facet_wrap(~identifier)
unique(dat$identifier)
